---
title: "Vince's LeetCode solutions with test cases."
output: html_document
---



LeetCode 1. Two Sum
```{python}

class Solution:
  def twoSum(self, nums: List[int], target: int) -> List[int]:
    for i in range (0, len(nums)):
      for j in range(i+1, len(nums)):
        # print('[', i, j,']', nums[i], nums[j], '=', (nums[i] + nums[j]), '?=', target)
        if nums[i] + nums[j] == target:
          return [i, j]
    return None

print(Solution().twoSum(nums=[2, 7, 11, 15], target=9))
print(Solution().twoSum(nums=[3, 2, 4], target=6))
print(Solution().twoSum(nums=[3, 3], target=6))

```


LeetCode 2. Add Two Numbers
```{python}

```

```{python}

```

LeetCode 9. Palindrome Number
```{python}

# class Solution:
#     def isPalindrome(self, x: int) -> bool:
#         
#         #print("X = ", x)
#         if(x < 0):
#           #print("Less than zero.")
#           return False
#         
#         if(x == 0):
#           #print("Zero.")
#           return True
#         
#         x = str(x)
#         #print("X = ", x, "Length = ", len(x))
#         
#         if (len(x) == 1):
#           return True
# 
#         elif ((len(x) == 2) and (x[0] == x[1])):
#           return True
#         
#         elif ((len(x) == 2) and (x[0] != x[1])):
#           return False
#                 
#         elif(x[0] == x[len(x) - 1]):
#           nextX = x[1: len(x) - 1]
#           nextX = int(nextX)
#           print("Initiating recursion, X, NextX = ", x, nextX)
#           return(self.isPalindrome(nextX))
#           
#         else:
#           return False

class Solution:
  def isPalindrome(self, x: int) -> bool:
        
        #print("X = ", x)
    if(x < 0):
      #print("Less than zero.")
      return False
        
    if(x == 0):
      #print("Zero.")
      return True
        
    x = str(x)

    return x == x[::-1]

    
print(Solution().isPalindrome(x = -1234))
print(Solution().isPalindrome(x = 10))
print(Solution().isPalindrome(x = 1234))
print(Solution().isPalindrome(x = 123432))
print(Solution().isPalindrome(x = 0))
print(Solution().isPalindrome(x = 1))
print(Solution().isPalindrome(x = 101))
print(Solution().isPalindrome(x = 1234321))

print(Solution().isPalindrome(x = 1000021))

```


??? Palindrom words.
```{python}
class Solution:
  def isPalindrome(self, s: str) -> bool:

    # Remove punctuation and force lowercase
    s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()

    return s == s[::-1]

    
print(Solution().isPalindrome(s = "abba"))
print(Solution().isPalindrome(s = "abcd"))
print(Solution().isPalindrome(s = "abcdedcba"))
print(Solution().isPalindrome(s = "A man, a plan, a canal: Panama"))
print(Solution().isPalindrome(s = "race a car"))
print(Solution().isPalindrome(s = " "))
print(Solution().isPalindrome(s = "0P"))
```


LeetCode 12. Integer to Roman
```{python}

```


LeetCode 13. Roman to Integer
```{python}

class Solution:
    def romanToInt(self, s: str) -> int:
        total = 0
        
        roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500,
          'M': 1000}
        
        last = s[-1]
        for t in reversed(s):
          #print(t, last)
          if t == 'C' and last in ['D', 'M']:
            total -= roman[t]
            
          elif t == 'X' and last in ['L', 'C']:
            total -= roman[t]
            
          elif t == 'I' and last in ['V', 'X']:
            total -= roman[t]
            
          else:
            total += roman[t]
          last = t
          
        return total


print(Solution().romanToInt(s = 'I'))
print(Solution().romanToInt(s = 'IV'))
print(Solution().romanToInt(s = 'VI'))

print(Solution().romanToInt(s = 'IX'))
print(Solution().romanToInt(s = 'X'))
print(Solution().romanToInt(s = 'XI'))

print(Solution().romanToInt(s = 'XL'))
print(Solution().romanToInt(s = 'LI'))
print(Solution().romanToInt(s = 'LIII'))

print(Solution().romanToInt(s = 'XCIII'))
print(Solution().romanToInt(s = 'C'))
print(Solution().romanToInt(s = 'MXCIV'))
```


LeetCode 13. Longest Common Prefix
```{python}

```


LeetCode 53. Maximum Subarray
```{python}

class Solution:
  def maxSubArray(self, nums: List[int]) -> int:
    maxEndingHere = maxSoFar = nums[0]
    
    for i in range(1, len(nums)):
      maxEndingHere = max(maxEndingHere + nums[i], nums[i])
      maxSoFar = max(maxSoFar, maxEndingHere)
      
    return maxSoFar

print(Solution().maxSubArray(nums = [-2,1,-3,4,-1,2,1,-5,4]))
print(Solution().maxSubArray(nums = [1]))
print(Solution().maxSubArray(nums = [5,4,-1,7,8]))

```

LeetCode 88. Merge Sorted Array
```{python}
class Solution:
  def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
    """
    Do not return anything, modify nums1 in-place instead.
    """
        
```

LeetCode 118. Pascal's Triangle.
```{python}
from math import comb
from typing import List

class Solution:
  def generate(self, numRows: int) -> List[List[int]]:
    allRows = []
    for i in range(numRows):
      rowI = []
      
      for j in range(i + 1):
        rowI.append(comb(i, j))
      
      allRows.append(rowI)
  
    return allRows

```

Test cases:
```{python}
print(Solution().generate(numRows = 1))
print(Solution().generate(numRows = 2))
print(Solution().generate(numRows = 3))
print(Solution().generate(numRows = 4))
print(Solution().generate(numRows = 5))


```


LeetCode 119. Pascal's Triangle 2.
```{python}
from math import comb

class Solution:
  def getRow(self, rowIndex: int) -> List[int]:
    thisRow = []
    
    for j in range(rowIndex + 1):
        thisRow.append(comb(rowIndex, j))
  
    return thisRow

# Test cases

print(Solution().getRow(rowIndex = 0))
print(Solution().getRow(rowIndex = 1))
print(Solution().getRow(rowIndex = 2))
print(Solution().getRow(rowIndex = 3))
print(Solution().getRow(rowIndex = 4))

```


LeetCode 121. Best Time to Buy and Sell Stock
```{python}
class Solution:
  def maxProfit(self, prices: List[int]) -> int:
    maxProfit = 0
    left = 0
    right = 1
       
    while right < len(prices):
      if prices[left] < prices[right]:
        currentProfit = prices[right] - prices[left]
        maxProfit = max(maxProfit, currentProfit)
      else:
        left = right
      right += 1
        
    return maxProfit

# Test Cases

print(Solution().maxProfit(prices = [7,1,5,3,6,4]))
print(Solution().maxProfit(prices = [7,6,4,3,1]))

```

LeetCode 122. Best Time to Buy and Sell Stock II
```{python}

```

LeetCode 123. Best Time to Buy and Sell Stock III
```{python}

```

LeetCode 125. Valid Palindrome
```{python}

```


  LeetCode 556. Reshape the Matrix.
```{python}
class Solution:
  def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:



```
